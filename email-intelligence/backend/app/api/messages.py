"""Message sampling API.

The dashboard is aggregation-first (tree + clusters). For UI details, we expose a small
"sample" endpoint that returns a handful of representative message rows for the currently
selected node.

This is intentionally metadata-first:
- No bodies are returned.
- Includes Gmail label IDs so users can see folder/label membership.

Node IDs are generated by the dashboard endpoint (see app.api.dashboard).
"""

from __future__ import annotations

from datetime import datetime, timezone

from fastapi import APIRouter, Query

from app.api.models import EmailMessageSummary, MessageSamplesResponse
from app.settings import Settings

router = APIRouter(prefix="/api/messages", tags=["messages"])


_LABEL_MAP_CACHE: dict[str, str] | None = None


def _split_node_id(node_id: str) -> tuple[str, list[str]]:
    """Parse a dashboard node_id into (kind, parts).

    Expected forms:
      - root
      - sender:<from_domain>
      - cluster:<uuid>
      - cluster:unclustered:<category>:<sub>
      - cat:<category>
      - sub:<category>:<sub>

    Returns:
        (kind, parts)
    """

    if node_id == "root":
        return ("root", [])

    if ":" not in node_id:
        return (node_id, [])

    kind, rest = node_id.split(":", 1)
    parts = [p for p in rest.split(":") if p]
    return (kind, parts)


@router.get("/samples", response_model=MessageSamplesResponse)
def message_samples(
    node_id: str = Query(..., description="Dashboard node id"),
    limit: int = Query(25, ge=1, le=200),
) -> MessageSamplesResponse:
    """Return sample messages for a dashboard node.

    This is best-effort and intended for UI exploration.
    """

    from sqlalchemy import text

    from app.db.postgres import engine

    global _LABEL_MAP_CACHE

    kind, parts = _split_node_id(node_id)

    # Keep samples consistent with the dashboard tree: exclude Trash.
    where = "NOT ('TRASH' = ANY(COALESCE(label_ids, ARRAY[]::text[])))"
    params: dict[str, object] = {"limit": limit}

    if kind == "root":
        # No additional filter.
        where = where
    elif kind == "sender" and parts:
        where += " AND from_domain = :from_domain"
        params["from_domain"] = parts[0]
    elif kind == "cluster" and parts:
        key = parts[0]
        if key == "unclustered":
            where += " AND cluster_id IS NULL"
        else:
            # cluster IDs are UUIDs stored in email_message.cluster_id
            where += " AND cluster_id::text = :cluster_id"
            params["cluster_id"] = key
    elif kind == "cat" and parts:
        cat = parts[0]
        if cat == "Pending labelling":
            where += " AND category IS NULL"
        else:
            where += " AND category = :category"
            params["category"] = cat
    elif kind == "sub" and len(parts) >= 2:
        cat, sub = parts[0], parts[1]
        if cat == "Pending labelling":
            where += " AND category IS NULL"
        else:
            where += " AND category = :category"
            params["category"] = cat

        if sub == "(unspecified)":
            where += " AND COALESCE(subcategory, '') = ''"
        else:
            where += " AND subcategory = :subcategory"
            params["subcategory"] = sub

    q = text(
        f"""
        SELECT
            gmail_message_id,
            subject,
            from_domain,
            internal_date,
            is_unread,
            category,
            subcategory,
            label_ids
        FROM email_message
        WHERE {where}
        ORDER BY internal_date DESC, gmail_message_id DESC
        LIMIT :limit
        """
    )

    with engine.begin() as conn:
        rows = conn.execute(q, params).fetchall()

    # Best-effort label id -> name resolution (used to show "folders" in UI).
    if _LABEL_MAP_CACHE is None:
        try:
            from app.gmail.client import get_gmail_service_from_files, list_label_names

            s = Settings()
            service = get_gmail_service_from_files(
                credentials_path=s.gmail_credentials_path,
                token_path=s.gmail_token_path,
                allow_interactive=False,
            )
            _LABEL_MAP_CACHE = list_label_names(service, user_id=s.gmail_user_id)
        except Exception:
            _LABEL_MAP_CACHE = {}

    msgs: list[EmailMessageSummary] = []
    for r in rows:
        label_ids = list(r[7] or [])
        label_names = [
            _LABEL_MAP_CACHE.get(lid, lid) if _LABEL_MAP_CACHE is not None else lid
            for lid in label_ids
        ]
        msgs.append(
            EmailMessageSummary(
                gmail_message_id=r[0],
                subject=r[1],
                from_domain=r[2],
                internal_date=r[3],
                is_unread=bool(r[4]),
                category=r[5],
                subcategory=r[6],
                label_ids=label_ids,
                label_names=label_names,
            )
        )

    return MessageSamplesResponse(
        node_id=node_id,
        generated_at=datetime.now(timezone.utc),
        messages=msgs,
    )
